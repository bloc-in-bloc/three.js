<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - postprocessing - Outline pass draco model</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
<div id="info">
	<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Outline Pass by <a href="http://eduperiment.com" target="_blank" rel="noopener">Prashant Sharma</a> and <a href="https://clara.io" target="_blank" rel="noopener">Ben Houston</a><br/><br/>
</div>

<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

<script type="module">

	import * as THREE from 'three';

	import Stats from './jsm/libs/stats.module.js';
	import { GUI } from './jsm/libs/lil-gui.module.min.js';

	import { OrbitControls } from './jsm/controls/OrbitControls.js';
	import { GLTFLoader } from "./jsm/loaders/GLTFLoader.js";
	import { DRACOLoader } from "./jsm/loaders/DRACOLoader.js";
	import { EffectComposer } from './jsm/postprocessing/EffectComposer.js';
	import { RenderPass } from './jsm/postprocessing/RenderPass.js';
	import { ShaderPass } from './jsm/postprocessing/ShaderPass.js';
	import { OutlinePass } from './jsm/postprocessing/OutlinePass.js';
	import { FXAAShader } from './jsm/shaders/FXAAShader.js';

	let container, stats;
	let camera, scene, renderer, controls;
	let composer, effectFXAA, outlinePass;

	let selectedObjects = [];

	const raycaster = new THREE.Raycaster();
	const mouse = new THREE.Vector2();

	const obj3d = new THREE.Object3D();
	const group = new THREE.Group();

	const params = {
		edgeStrength: 3.0,
		edgeGlow: 0.0,
		edgeThickness: 1.0,
		pulsePeriod: 0,
		rotate: false,
		usePatternTexture: false
	};

	// Init gui

	const gui = new GUI( { width: 280 } );

	gui.add( params, 'edgeStrength', 0.01, 10 ).onChange( function ( value ) {

		outlinePass.edgeStrength = Number( value );

	} );

	gui.add( params, 'edgeGlow', 0.0, 1 ).onChange( function ( value ) {

		outlinePass.edgeGlow = Number( value );

	} );

	gui.add( params, 'edgeThickness', 1, 4 ).onChange( function ( value ) {

		outlinePass.edgeThickness = Number( value );

	} );

	gui.add( params, 'pulsePeriod', 0.0, 5 ).onChange( function ( value ) {

		outlinePass.pulsePeriod = Number( value );

	} );

	gui.add( params, 'rotate' );

	gui.add( params, 'usePatternTexture' ).onChange( function ( value ) {

		outlinePass.usePatternTexture = value;

	} );

	function Configuration() {

		this.visibleEdgeColor = '#ffffff';
		this.hiddenEdgeColor = '#190a05';

	}

	const conf = new Configuration();

	gui.addColor( conf, 'visibleEdgeColor' ).onChange( function ( value ) {

		outlinePass.visibleEdgeColor.set( value );

	} );

	gui.addColor( conf, 'hiddenEdgeColor' ).onChange( function ( value ) {

		outlinePass.hiddenEdgeColor.set( value );

	} );

	init();
	animate();

	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		const width = window.innerWidth;
		const height = window.innerHeight;

		renderer = new THREE.WebGLRenderer();
		renderer.shadowMap.enabled = true;
		// todo - support pixelRatio in this demo
		renderer.setSize( width, height );
		document.body.appendChild( renderer.domElement );

		scene = new THREE.Scene();
		scene.background = new THREE.Color(0xefefef);

		camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 3000 );
		camera.position.set( 0, 0, 500 );

		controls = new OrbitControls( camera, renderer.domElement );
		controls.minDistance = 2;
		controls.maxDistance = 1000;

		// Lights

		const directionalLight1 = new THREE.DirectionalLight(0xffeeff, 0.8);
		directionalLight1.position.set(1, 1, 1);
		scene.add(directionalLight1);

		const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
		directionalLight2.position.set(-1, 0.5, -1);
		scene.add(directionalLight2);

		const ambientLight = new THREE.AmbientLight(0xffffee, 0.25);
		scene.add(ambientLight);

		// model

		const loader = new GLTFLoader().setPath("models/draco-glb/");
		const dracoLoader = new DRACOLoader().setDecoderPath("https://threejs.org/examples/js/libs/draco/");
		loader.setDRACOLoader(dracoLoader);
		loader.load("bimworld.glb", (gltf) => {
				scene.add(gltf.scene);
			}
		);

		//

		stats = new Stats();
		container.appendChild( stats.dom );

		// postprocessing

		composer = new EffectComposer( renderer );

		const renderPass = new RenderPass( scene, camera );
		composer.addPass( renderPass );

		outlinePass = new OutlinePass( new THREE.Vector2( window.innerWidth, window.innerHeight ), scene, camera );
		composer.addPass( outlinePass );

		const textureLoader = new THREE.TextureLoader();
		textureLoader.load( 'textures/tri_pattern.jpg', function ( texture ) {

			outlinePass.patternTexture = texture;
			texture.wrapS = THREE.RepeatWrapping;
			texture.wrapT = THREE.RepeatWrapping;

		} );

		effectFXAA = new ShaderPass( FXAAShader );
		effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );
		composer.addPass( effectFXAA );

		window.addEventListener( 'resize', onWindowResize );

		renderer.domElement.style.touchAction = 'none';
		renderer.domElement.addEventListener( 'pointermove', onPointerMove );

		function onPointerMove( event ) {

			if ( event.isPrimary === false ) return;

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			checkIntersection();

		}

		function addSelectedObject( object ) {

			selectedObjects = [];
			selectedObjects.push( object );

		}

		function checkIntersection() {

			raycaster.setFromCamera( mouse, camera );

			const intersects = raycaster.intersectObject( scene, true );

			if ( intersects.length > 0 ) {

				const selectedObject = intersects[ 0 ].object;
				addSelectedObject( selectedObject );
				outlinePass.selectedObjects = selectedObjects;

			} else {

				// outlinePass.selectedObjects = [];

			}

		}

	}

	function onWindowResize() {

		const width = window.innerWidth;
		const height = window.innerHeight;

		camera.aspect = width / height;
		camera.updateProjectionMatrix();

		renderer.setSize( width, height );
		composer.setSize( width, height );

		effectFXAA.uniforms[ 'resolution' ].value.set( 1 / window.innerWidth, 1 / window.innerHeight );

	}

	function animate() {

		requestAnimationFrame( animate );

		stats.begin();

		const timer = performance.now();

		if ( params.rotate ) {

			group.rotation.y = timer * 0.0001;

		}

		controls.update();

		composer.render();

		stats.end();

	}

</script>
</body>
</html>
