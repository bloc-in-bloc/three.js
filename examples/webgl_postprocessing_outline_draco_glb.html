<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - postprocessing - Outline pass draco model</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from "three";
			import { GLTFLoader } from "./jsm/loaders/GLTFLoader.js";
			import { DRACOLoader } from "./jsm/loaders/DRACOLoader.js";
			import { EffectComposer } from "./jsm/postprocessing/EffectComposer.js";
			import { RenderPass } from "./jsm/postprocessing/RenderPass.js";
			import { OutlinePass } from "./jsm/postprocessing/OutlinePass.js";
			import { OrbitControls } from "./jsm/controls/OrbitControls.js";

			let camera, scene, renderer, loader, composer, renderPass, outlinePass;init();
			render();

			function init() {
				const container = document.createElement("div");
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 3000);
				camera.position.set(0, 10, 500);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0xefefef);

				// Lights
				const directionalLight1 = new THREE.DirectionalLight(0xffeeff, 0.8);
				directionalLight1.position.set(1, 1, 1);
				scene.add(directionalLight1);

				const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
				directionalLight2.position.set(-1, 0.5, -1);
				scene.add(directionalLight2);

				const ambientLight = new THREE.AmbientLight(0xffffee, 0.25);
				scene.add(ambientLight);

				renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.setClearColor(0x000000, 0);

				container.appendChild(renderer.domElement);

				window.addEventListener("resize", onWindowResize);

				initPostProcessing();

				loader = new GLTFLoader().setPath("models/draco-glb/");
				const dracoLoader = new DRACOLoader().setDecoderPath("https://threejs.org/examples/js/libs/draco/");
				loader.setDRACOLoader(dracoLoader);

				const files = ["bimworld.glb"];
				loadFiles(files);

				const controls = new OrbitControls(camera, renderer.domElement);
				controls.addEventListener("change", render); // use if there is no animation loop
				controls.minDistance = 2;
				controls.maxDistance = 1000;
				controls.target.set(0, 0, -0.2);
				controls.update();
			}

			function initPostProcessing() {
				let width = window.innerWidth;
				let height = window.innerHeight;
				const renderTarget = new THREE.WebGLRenderTarget(width, height, {
					// Improve color rendering
					encoding: THREE.sRGBEncoding,
					type: THREE.FloatType
				});

				composer = new EffectComposer(renderer, renderTarget);
				composer.setPixelRatio(renderer.getPixelRatio());

				renderPass = new RenderPass(scene, camera);
				composer.addPass(renderPass);

				outlinePass = new OutlinePass(new THREE.Vector2(width, height), scene, camera);
				outlinePass.edgeStrength = 10;
				outlinePass.edgeThickness = 1;
				outlinePass.visibleEdgeColor.set(0x00FF00);
				outlinePass.hiddenEdgeColor.set(0X7A7A7A);
				composer.addPass(outlinePass);
				composer.setSize(width, height);
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
				render();
			}

			function render() {
				// renderer.render(scene, camera);
				composer.render();
			}

			function loadFiles(files) {
				const start = performance.now();
				return Promise.all(files.map(file => {
					return new Promise((resolve, reject) => {
						loader.load(file,
							(gltf) => {
								scene.add(gltf.scene);
								resolve(true);
							}
						);
					});
				})).then(() => {
					render();
					console.log("Total loading time", performance.now() - start);
				});
			}

		</script>

	</body>
</html>
